getwd()
currDir = getwd()
paste(currDir, "", sep = "/Getting and Cleaning Data/week1")
source('~/Documents/Data-Science-in-R/Getting and Cleaning Data/week1/dataCollection.R', echo=TRUE)
list.files("./data")
download.file(fileURL, destfile = "data/cameras.csv", method = "curl")
source('~/Documents/Data-Science-in-R/Getting and Cleaning Data/week1/dataCollection.R', echo=TRUE)
source('~/Documents/Data-Science-in-R/Getting and Cleaning Data/week1/dataCollection.R', echo=TRUE)
currDir = getwd()
system("pwd")
getwd()
source('~/Documents/Data-Science-in-R/Getting and Cleaning Data/week1/dataCollection.R', echo=TRUE)
currDir = system("pwd")
newDir = paste(currDir, "", sep = "/Getting and Cleaning Data/week1")
newDir
as.character(system("pwd"))
currDir = getwd()
newDir = paste(currDir, "", sep = "/Getting and Cleaning Data/week1")
newDir
setwd(newDir)
getwd()
system("pwd")
system("ls")
# dir to store downloaded data
if(!file.exists("downloaded")){
dir.create("downloaded")
}
fileURL = "https://data.baltimorecity.gov/api/views/dz54-2aru/rows.csv?accessType=DOWNLOAD"
download.file(fileURL, destfile = "./downloaded/cameras.csv", method = "curl")
list.files("./downloaded")
list.files("./downloaded")
dateDownloaded <- date()
dateDownloaded
source('~/Documents/Data-Science-in-R/Getting and Cleaning Data/week1/readData.R', echo=TRUE)
getwd()
## reading data
cameraData <- read.table("downloaded/cameras.csv")
## reading data
cameraData <- read.table("downloaded/cameras.csv", sep = ",", header = TRUE)
head(cameraData)
fileCSV = "https://data.baltimorecity.gov/api/views/dz54-2aru/rows.csv?accessType=DOWNLOAD"
fileXCL = "https://data.baltimorecity.gov/api/views/dz54-2aru/rows.xlsx?accessType=DOWNLOAD"
fileXML = "https://data.baltimorecity.gov/api/views/dz54-2aru/rows.xml?accessType=DOWNLOAD"
fileJSON = "https://data.baltimorecity.gov/api/views/dz54-2aru/rows.json?accessType=DOWNLOAD"
download.file(fileCSV, destfile = "./downloaded/cameras.csv", method = "curl")
download.file(fileXCL, destfile = "./downloaded/cameras.xlsx", method = "curl")
download.file(fileXML, destfile = "./downloaded/cameras.xml", method = "curl")
download.file(fileJSON, destfile = "./downloaded/cameras.json", method = "curl")
library(jsonlite)
cameraDataJSON <- read.table("downloaded/cameras.json", sep = ",", header = TRUE)
cameraDataJSON <- fromJSON("downloaded/cameras.json")
head(cameraDataJSON)
names(cameraDataJSON)
names(cameraDataJSON$meta)
cameraDataJSON <- fromJSON("https://api.github.com/users/jtleek/repos")
names(cameraDataJSON)
head(cameraDataJSON)
names(cameraDataJSON$owner)
names(cameraDataJSON$owner$login)
cameraDataJSON <- fromJSON("https://api.github.com/users/ravi-prakash1907/repos")
names(cameraDataJSON)
names(cameraDataJSON$owner)
names(cameraDataJSON$owner$login)
# converting to json
mjson <- toJSON(iris, pretty = T)
cat(myjson)
# converting to json
myjson <- toJSON(iris, pretty = T)
cat(myjson)
cameraDataXML <- xmlTreeParse("http://www.w3schools.com/xml/simple.xml", useInternal = TRUE)
rootNode <- xmlRoot(cameraDataXML)
xmlName(rootNode)
library(XML)
cameraDataXML <- xmlTreeParse("http://www.w3schools.com/xml/simple.xml", useInternal = TRUE)
rootNode <- xmlRoot(cameraDataXML)
xmlName(rootNode)
###############################
# XML
cameraDataXML <- xmlTreeParse("http://www.w3schools.com/xml/simple.xml", useInternalNodes = TRUE)
library(XML2)
library(xml2)
###############################
# XML
cameraDataXML <- xmlParseDoc("http://www.w3schools.com/xml/simple.xml", useInternalNodes = TRUE)
source('~/Documents/Data-Science-in-R/Getting and Cleaning Data/week1/readData.R', echo=TRUE)
library(xlsx)
library(XML)
library(jsonlite)
# library
library(XLSX)
library(XML)
library(jsonlite)
#cameraDataCSV <- read.csv("downloaded/cameras.csv")
cameraDataCSV <- read.table("downloaded/cameras.csv", sep = ",", header = TRUE)
c = 2:3
r = 1:4
cameraDataXCL <- read.xlsx("downloaded/cameras.xlsx", sheetIndex = "1", header = TRUE) # colIndex=c, rowIndex=r
# viewing
head(cameraDataCSV)
head(cameraDataXCL)
###############################
# XML
cameraDataXML <- xmlTreeParse("http://www.w3schools.com/xml/simple.xml", useInternal = TRUE)
###############################
# XML
cameraDataXML <- xmlTreeParse("http://www.w3schools.com/xml/simple.xml", useInternal=TRUE)
###############################
# XML
URL = "http://www.w3schools.com/xml/simple.xml"
cameraDataXML <- xmlTreeParse(URL, useInternal=TRUE)
URL = "downloaded/cameras.xml"
cameraDataXML <- xmlTreeParse(URL, useInternal=TRUE)
rootNode <- xmlRoot(cameraDataXML) # FINDSthe root node of XML doc
xmlName(rootNode) # prints the root
names(rootNode) # prints the names of nodes next in the root
rootNode[[1]] # whole first instance of first internal node
rootNode <- xmlRoot(rootNode) # going one more level down (for camera.xml only)
cameraDataXML <- xmlTreeParse(URL, useInternal=TRUE)
rootNode <- xmlRoot(cameraDataXML) # FINDSthe root node of XML doc
xmlName(rootNode) # prints the root
rootNode <- xmlRoot(rootNode) # going one more level down (for camera.xml only)
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[[1]]] # whole first instance of first internal node
rootNode[[[1][1]]] # whole first instance of first internal node
rootNode[[1]][[1]] # whole first instance of first internal node
######################
rootNode = rootNode[[1]][[1]]
xmlSApply(rootNode, xmlValue)
## Using XPath
xmlSApply(rootNode, "//crossstreet" xmlValue)
## Using XPath
xmlSApply(rootNode, "//crossstreet", xmlValue)
rootNode <- xmlRoot(rootNode) # going one more level down (for camera.xml only)
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[1]][[1]]
######################
rootNode2 = rootNode[[1]][[1]]
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
xmlSApply(rootNode2, xmlValue) # see how
## Using XPath
xmlSApply(rootNode, "//crossstreet", xmlValue)
## Using XPath
xmlSApply(rootNode, "/crossstreet", xmlValue)
rootNode <- xmlRoot(rootNode) # going one more level down (for camera.xml only)
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[1]][[1]]
######################
rootNode = rootNode[[1]][[1]]
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
xmlSApply(rootNode, xmlValue) # see how
## Using XPath
xmlSApply(rootNode, "//crossstreet", xmlValue)
## Using XPath
xmlSApply(rootNode, "//row", xmlValue)
## Using XPath
xmlSApply(rootNode, "/row", xmlValue)
## Using XPath
xmlSApply(rootNode, "/crossstreet", xmlValue)
rootNode <- xmlRoot(rootNode) # going one more level down (for camera.xml only)
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[1]][[1]]
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
xmlSApply(rootNode, xmlValue) # see how
######################
rootNode2 = rootNode[[1]][[1]]
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
xmlSApply(rootNode2, xmlValue) # see how
## Using XPath
xmlSApply(rootNode, "/crossstreet", xmlValue)
###############################
# XML
URL = "downloaded/simple.xml"
cameraDataXML <- xmlTreeParse(URL, useInternal=TRUE)
rootNode <- xmlRoot(cameraDataXML) # FINDSthe root node of XML doc
xmlName(rootNode) # prints the root
rootNode <- xmlRoot(rootNode) # going one more level down (for camera.xml only)
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[1]][[1]]
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
xmlSApply(rootNode2, xmlValue) # see how
cameraDataXML <- xmlTreeParse(URL, useInternal=TRUE)
rootNode <- xmlRoot(cameraDataXML) # FINDSthe root node of XML doc
xmlName(rootNode) # prints the root
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[1]][[1]]
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
xmlSApply(rootNode2, xmlValue) # see how
## Using XPath
xmlSApply(rootNode, "//name", xmlValue)
cameraDataXML <- xmlTreeParse(URL, useInternal=TRUE)
rootNode <- xmlRoot(cameraDataXML) # FINDSthe root node of XML doc
xmlName(rootNode) # prints the root
#rootNode <- xmlRoot(rootNode) # going one more level down (for camera.xml only)
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[1]][[1]]
######################
#rootNode2 = rootNode[[1]][[1]] # for camera.xml
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
#xmlSApply(rootNode2, xmlValue)
xmlSApply(rootNode, xmlValue)
## Using XPath
xmlSApply(rootNode, "/crossstreet", xmlValue)
cameraDataXML <- xmlTreeParse(URL, useInternal=TRUE)
rootNode <- xmlRoot(cameraDataXML) # FINDSthe root node of XML doc
xmlName(rootNode) # prints the root
# prints the names of nodes next in the root
names(rootNode) # return as many time as ever inter nodes are
rootNode[[1]] # whole first instance of first internal node
rootNode[[1]][[1]]
# xmlSApply()    :      it returns the actual value of that node i.e. inside the XML tag
#xmlSApply(rootNode2, xmlValue)
xmlSApply(rootNode, xmlValue)
## Using XPath
xmlSApply(rootNode, "//row", xmlValue)
rootNode
## Using XPath
#xmlSApply(rootNode, "/crossstreet", xmlValue)
xmlSApply(rootNode, "//name", xmlValue)
## Using XPath
#xpathSApply(rootNode, "/crossstreet", xmlValue)
xpathSApply(rootNode, "//name", xmlValue)
xpathSApply(rootNode, "//price", xmlValue)
# XML of any random page source code
URL = "http://espn.go.com/nfl/team/_/name/baltimore-ravens"
doc <- htmlTreeParse(URL, useInternal=T)
doc <- htmlTreeParse(URL, useInternalNodes = T)
# XML of any random page source code
URL = "http://espn.go.com/nfl/team/_/name/baltimore-ravens"
doc <- htmlTreeParse(URL, useInternal = TRUE)
score <- xpathApply(doc, "//li@class='score'", xmlValue)
teams <- xpathApply(doc, "//li@class='team-name'", xmlValue)
library(XML)
URL = "https://www.mohfw.gov.in/"
cameraDataXML <- htmlTreeParse(URL, useInternal=TRUE)
# XML of any random page source code
URL = "http://espn.go.com/nfl/team/_/name/baltimore-ravens"
doc <- htmlTreeParse(URL, useInternal = TRUE)
URL = "https://www.mohfw.gov.in/"
doc <- htmlTreeParse(URL, useInternal = TRUE)
doc <- htmlTreeParse(URL, useInternal = TRUE, methods(curl))
library(xml2)
?htmlParse
?html_structure
#doc <- htmlTreeParse(URL, useInternal = TRUE, methods(curl))
doc <- read_html(URL)
html_structure(doc)
doc
d = xmlTreeParse(doc)
xmlRoot(d)
xmlRoot(doc)
htmlRoot(doc)
getwd()
class(system("ls"))
?system
dir()
getwd()
## Library
library(RMySQL)
install.packages(RMySQL)
install.packages('RMySQL')
## Library
library(RMySQL)
ucscDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.ucsc.edu")
# executing query and disconnecting
result <- dbGetQuery(ucscDb, "get databases;"); dbDisconnect(ucscDb);
# executing query and disconnecting
result <- dbGetQuery(ucscDb, "get databases;")
## Library
library(RMySQL)
# connecting to server
ucscDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.ucsc.edu")
# executing query and disconnecting
result <- dbGetQuery(ucscDb, "get databases;")
# executing query and disconnecting
result <- dbGetQuery(ucscDb, "show databases;"); dbDisconnect(ucscDb);
result
getwd()
source('~/Documents/Data-Science-in-R/reader.R', echo=TRUE)
## Library
library(RMySQL)
# connecting to server
ucscDb <- dbConnect(MySQL(), user="genome", host="genome-mysql.cse.ucsc.edu")
# executing query and disconnecting
result <- dbGetQuery(ucscDb, "show databases;"); dbDisconnect(ucscDb);
result # list of the databases
# connecting to specifically 1 database     ---->     hg19
ucscDb <- dbConnect(MySQL(), user="genome", db="hg19", host="genome-mysql.cse.ucsc.edu")
allTables = dbListTables(hg19)
# connecting to specifically 1 database     ---->     hg19
hg19 <- dbConnect(MySQL(), user="genome", db="hg19", host="genome-mysql.cse.ucsc.edu")
allTables = dbListTables(hg19)
length(allTables)
class(allTables)
head(allTables)
allTables[11:15]
# fibding the Fields in a table of the current database
dbListFields(hg19, "affyU113Plus2")
# fibding the Fields in a table of the current database
dbListFields(hg19, "affyU133Plus2")
# fibding the Fields in a table of the current database
dbListFields(hg19, "affyU133Plus2")
dbListFields(hg19, "affyU133Plus2")
# fibding the Fields in a table of the current database
dbListFields(hg19, "affyCytoScan")
dbGetQuery(hg19, "select count(*) from affyCytoScan")
dbGetQuery(hg19, "select count(*) from affyU133Plus2")
# reading a TABLE
affyData <- dbReadTable(hg19, "affyU133Plus2")
class(affyData)
head(affyData)
# subset data
query <- dbSendQuery(hg19, "select * from affyU133Plus2 where misMatches between 1 and 3")
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch);
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMisSmall <- fetch()
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMisSmall <- fetch()
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch)
affyMisSmall <- fetch(query, n=10); dbClearResult(query)
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch) # still reading and will return other o/p when run again
# subset data
query <- dbSendQuery(hg19, "select * from affyU133Plus2 where misMatches between 1 and 3")
affyMis <- fetch(query, n=10); quantile(affyMis$misMatch) # still reading and will return other o/p when run again
dim(affyMisSmall)
dbDisconnect(hg19)
getwd()
# r hdf5 pkg is installed from bioconductor
source("http://bioconductor.org/biocLite.R")
# r hdf5 pkg is installed from bioconductor
source("https://bioconductor.org/biocLite.R")
############################
# Installing Bioconductor
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install()
